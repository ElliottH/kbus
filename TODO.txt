A crude to-do list
==================

In no particular order (well, except for the first):

* REQ Always, update documentation.

* REQ Allow a KSock to say "I am a network bridge", which means that
  messages going over it might be hard to follow -- one might not be sure if
  they've been delivered or not, and so it may be sensible to be able to tell
  that a message has "gone fuzzy" -- sending to such an interface should maybe
  set some status on the "retval+status" from a send.

  Thus "send" should tell the caller as much as it can about how successful
  it has been (including, if it can tell, that delivery has definitely worked
  or failed).

* REQ Probably keep a spare slot in the receiver queue, to allow for receiving
  asynchronous error messages.

* DONE *(but held here as details may change)* "send" should return:

  1. (as return code):

        * 0 if all has gone well
        * negative value if the message was invalid in some way, or for any
          other error that we can *guarantee* can be caught by "send", even
          if sending to a remote destination -- so basically, any error
          detectable before the actual delivery stage.

  2. (as ioctl argument)
     
        * last message id
          to save the caller having to look it up after the fact. Since an
          error message relating to the sent message uses its 'in_reply_to'
          field to indicate which message it is an error message about, this
          makes the caller's life a lot simpler (having to always do
          <send>;<get_last_msg_id> is messy).

        * a "hint" when we know more information about what has been sent.
          Specifically:

            * 0 if we have no more information
            * 1 if we know that the send has successfully placed the messages
              in the queues for the appropriate receivers (for an internal
              KBUS send, this will be the normal "success" case)
            * 2 if we know that some problem occurred during the send, which
              has resulted in an error message being synthesised and sent

     That last is intended to allow the caller of "send" to be aware that they
     have an error message waiting for them to read - it is an optimisation.
     Clearly it will not be available for message sent over a bridge or some
     other abstraction mechanism.

     Decisions then need to be made about what can return a "straight" return
     code, and what needs to be mediated by an error message.

* QUESTION: If a user generates a Reply, with no antecedent Request, is that
  still a legitimate message? 

  In particular, if an apparent Reply is created, and sent, but the intended
  recipient has no reason to expect this message, is that an error, or just
  something odd one should generally avoid doing?

  It is is an error, then the (notional) sender needs to have a list of the
  Requests that it has sent. so that it can reject this message as not
  belonging.

      NB: When an error message is generated, it's "in_reply_to" field is used
      to hold the id of the message that caused the error. Thus an error
      message (a message synthetically generated by KBUS) is normally
      (always?) an unsolicited Reply (of course, sometimes it is instead of a
      requested reply, as well).

      So does that alter my opinion?

* REQ Implement sender ALL/WAIT flags:

  - ALL_OR_WAIT -- add the message to all listener queues, and if that can't
    be done because some queues are full, the sender should block on its SEND
    until it can be done.

  - ALL_OR_FAIL -- add the message to all listener queues, and if that can't
    be done, fail (the message is not sent).

  - DONE: (default) -- add the message to all listener queues that have room.

  Remember that, in this context, and interpreted appropriately, repliers also
  count as listeners.

* REQ Make all the errors after the "this message is valid" step in 'send'
  produce KBUS messages, instead of returning an error code.

* REQ Police reply messages -- there may be one, and only one, reply for each
  request. It shall not be possible to send a reply that is not in response to
  a request. It shall be shiny.

        Or not. Do I actually care? After all, an exception/synthetic message
        also looks like a reply...

* OPT Internally, split messages into

      - header -- copy this between lists
      - message name/id -- if we're doing message name ids, then those should
        be copied prefererentially
      - message data -- this should be reference counted

* REQ Keep a list of all Requests that have not been replied to, and send the
  sender a synthetic message when an interface has released, or unbound, but
  has not replied to a message, even though it *has* read it.

  I might consider not doing this for the "unbind" case, since (a) it would be
  complicated and (b) the interface might well unbind and then bind again.
  Yes, that sounds a good excuse.

* REQ Provide a flag on file descriptors (hmm, perhaps better on an individual
  message?) to say:

  When I've sent a message, send me back a synthesised message when that
  message has "left the system" -- i.e., when all listeners (that are going
  to) have read it, when all repliers (that are going to) have replied to it,
  and (if that isn't going to happen) when any exceptions regarding it have
  been sent.

  In other words, if the sender is remembering information about messages that
  have been sent, this allows the sender to know that it can forget about the
  message.

* REQ Large message support -- allow message data to be large, held as a list
  of data split properly over pages. Really requires reference counting of
  message data.

* OPT Allow message name id to be used instead of message name in messages.
  This would need:

      - ability to look up message name and retrieve its id
      - a way of indicating whether a message is storing message name (and
        its length) or message name id
      - some better terminology for "message name id"

  Note that in the Python interface this is not a big deal to the user.

* OPT Support for poll/select.

* OPT Consider adding RESET functionality (the ioctl already exists):

  1. Sends exactly one '$.KBUS.Reset.Start' message to each open interface
     (so if one is listening and replying on an interface, one still only gets
     a single such message on it).
  2. Empties all of the queues -- this will generate any necessary synthetic
     messages/exceptions relating to dropped requests/replies.
  3. Resets all the internal ids (to start from 0 or 1 again).
  4. Sends exactly one '$.KBUS.Reset.End' message to each open interface.

  Consideration: this would mean that all interfaces were automatically bound
  to '$.KBUS.Reset.*'.

  Use case: This would be useful for testing, and if we have multiple
  interacting internal lists (for instance, message queues on each interface,
  but also a list of outstanding requests), then it allows for a "soft
  restart" other than removing and reinstalling the module.

* OPT Remove lots of the debugging 'printk's in ``kbus.c`` - there are way too
  many.

-------------------------------------------------------------------------------

* DONE Come up with a new name to replace KSock, so that other things can
  use that term without confusion.

        Slot, Port, Opening, Access, Talker, Bus, ...

        Socket ... KSock (? - suggested by JC)

        AccessPoint, EndPoint, ...

        Interlocutor, Protagonist, Participant, ...

  For the moment, go with KSock. It's not particularly nice, but:

  a. It's better than Elephant
  b. It's short
  c. It's not easy to confuse with some other term from somewhere else
  d. It does sound a bit like some sort of sockety thing, which is
     more-or-less the right sort of paradigm.

* DONE Message ids should have more "space"

  * Network id can be used to indicate that the message came from another
    namespace (e.g., through a bridge). Our local namespace has network id
    set to 0.

    KSock such as bridges, which pipe through messages from another
    namespace, can use the network id to (a) indicate that the local KBUS
    should not change the message id serial number, and (b) store whatever
    information is deemed useful in translating the message id back to the
    equivalent in the other namespace.

  * Message id is unique within a network/namespace. If network id is 0, then
    KBUS will assign a new message id to a message, on "send", when it has
    determined that the message is (basically) well formed. This means that
    after "send" one can always do "sender.get_last_msg_id()", and *that*
    allows one to identify the message being named in an exception message
    (a synthetic message from KBUS itself).

* DONE Implement maximum message queue length per interface -- so that if one
  keeps adding messages, and no-one is reading them, one doesn't fill up the
  world.

* DONE Reserve message names in '$.KBUS.*' for use by KBUS for synthetic messages.

  Only done "implicitly" - there is no intent to enforce this.

* DONE *Remove* GUARANTEED message delivery -- a listener is not allowed to
  say "I shall receive all messages with that name", because that could cause
  its queue to grow forever, and use up all memory, and we should be very sad,
  and all die, and that would be bad.

