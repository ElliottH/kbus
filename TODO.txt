A crude to-do list
==================

In no particular order (well, except for the first):

* REQ Always, update documentation.

* REQ Implement maximum message queue length per interface -- so that if one
  keeps adding messages, and no-one is reading them, one doesn't fill up the
  world.

* REQ Implement GUARANTEED message delivery (a listener *shall* receive all
  messages it is bound to, irrespective of the above point).

  - If a replier is not guaranteed to receive a request with a particular
    name, and its queue is full, then an attempt to send a new request with
    that name will fail, and KBUS will send a synthetic message to the sender
    to let it know this has occurred (an exception).

  - If a listener is not guaranteed to receive a message with a particula
    name, and its queue is full, then an attempt to send a new message with
    that name will just not add the message to its queue.

* REQ Implement sender ALL/WAIT flags:

  - ALL_OR_WAIT -- add the message to all listener queues (subject to the
    above guarantee flags), and if that can't be done because some queues are
    full, the sender should block on its SEND until it can be done.

  - ALL_OR_FAIL -- add the message to all listener queues, and if that can't
    be done, fail (the message is not sent).

  - GUARANTEED -- add the message to all listener queues that guarantee to
    receive the message, and any other listener queues that have room.

  Remember that, in this context, and interpreted appropriately, repliers also
  count as listeners, and may ask for GUARANTEED delivery or not.

* OPT Internally, split messages into

      - header -- copy this between lists
      - message name/id -- if we're doing message name ids, then those should
        be copied prefererentially
      - message data -- this should be reference counted

* OPT Allow message name id to be used instead of message name in messages.
  This would need:

      - ability to look up message name and retrieve its id
      - a way of indicating whether a message is storing message name (and
        its length) or message name id
      - some better terminology for "message name id"

  Note that in the Python interface this is not a big deal to the user.

* ??? Consider keeping a list of all outstanding messages. (Why?)

* REQ Consider keeping a list of all Requests that have not been replied to
  (this would allow kbus.c to notice that an interface has released, or
  unbound, but has not replied to a message, even though it *has* read it).
  I might consider not doing this for the "unbind" case, since (a) it would be
  complicated and (b) the interface might well unbind and then bind again.
  Yes, that sounds a good excuse.

* REQ Large message support -- allow message data to be large, held as a list
  of data split properly over pages. Really requires reference counting of
  message data.

* OPT Support for poll/select.

* DONE Reserve message names in '$.KBUS.*' for use by KBUS for synthetic messages.

* OPT Consider adding RESET functionality (the ioctl already exists):

  1. Sends exactly one '$.KBUS.Reset.Start' message to each open interface
     (so if one is listening and replying on an interface, one still only gets
     a single such message on it).
  2. Empties all of the queues -- this will generate any necessary synthetic
     messages/exceptions relating to dropped requests/replies.
  3. Resets all the internal ids (to start from 0 or 1 again).
  4. Sends exactly one '$.KBUS.Reset.End' message to each open interface.

  Consideration: this would mean that all interfaces were automatically bound
  to '$.KBUS.Reset.*'.

  Use case: This would be useful for testing, and if we have multiple
  interacting internal lists (for instance, message queues on each interface,
  but also a list of outstanding requests), then it allows for a "soft
  restart" other than removing and reinstalling the module.

* OPT Remove lots of the debugging 'printk's in ``kbus.c`` - there are way too
  many.
