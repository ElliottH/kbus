KBUS -- Lightweight kernel-mediated messaging
=============================================

XXX TODO: document the new next_msg/read and write/send mechanisms.

This is emergent documentation for the KBUS kernel module.

It is intended that (if kbus is installed) this document should work as a
doctest, testing that all Python examples actually work.

Intention
=========
KBUS provides lightweight kernel-mediated messaging for Linux.

* "lightweight" means that there is no intent to provide complex or
  sophisticated mechanisms - if you need something more, consider DBUS or
  other alternatives.

* "kernel-mediated" means that the actual business of message passing and
  message synchronisation is handled by a kernel module.

* "for Linux" means what it says - the initial code is for the Linux kernel.

Initial use is expected to be in embedded systems.

There is (at least initially) no intent to aim for a "fast" system - this is
not aimed at real-time systems.

Although the initial implementation is kernel-mediated, it is assumed that
there will eventually be bindings for message transmission over ethernet.

The basics
==========
Python
------
Although the KBUS kernel module is written in C, the modules tests are written
in Python, and there is a Python module providing useful interfaces, which is
expected to be the normal way of using KBUS (at least initially).

The KBUS devices
----------------
Message interactions happen via the KBUS devices. Installing the KBUS kernel
module always creates ``/dev/kbus0``, it may also create ``/dev/kbus1``, and
so on.

    The number of devices to create is indicated by an argument at module
    installation, for instance::

        # insmod kbus.ko num_kbus_devices=10

Messages are sent by writing to a KBUS device, and received by reading from
the same device. A variety of useful ioctls are also provided. Each KBUS
device is independent - messages cannot be sent from ``/dev/kbus0`` to
``/dev/kbus1``, since there is no shared information.

Messages
--------
All messages have names - for instance "$.Sensors.Kitchen".

All message names start with "$.", followed by one or more alphanumeric words
separated by dots. There are two wildcard characters, "*" and "%", which can
be the last word of a name.

Thus (in some notation or other)::

    name := '$.' + more
    more := ( word [ '.' more ]* ) | '*' | '%'
    word := alphanumerics

Case is significant. There is probably a limit on the maximum size of a
subname, and also on the maximum length of a message name.

Names form a name hierarchym or tree - so "$.Sensors" has children
"$.Sensors.Kitchen" and "$.Sensors.Bedroom".

If the last word of a name is "*", then this name also includes all the
child names at that level and below -- i.e., all the names that start with the
name up to the "*". So "$.Sensors.*" includes "$.Sensors.Kitchen",
"$.Sensors.Bedroom", "$.Sensors.Kitchen.FireAlarm",
"$.Sensors.Kitchen.Toaster", "$.Sensors.Bedroom.FireAlarm", and so on.

If the last word of a name is "%", then this name also includes all the child
names at that level -- i.e., all the names obtained by replacing the "%" by
another word. So "$.Sensors.%" includes "$.Sensors.Kitchen" and
"$.Sensors.Bedroom", but not "$.Sensors.Kitchen.Toaster".

Message ids
-----------
Every message is given a unique id by KBUS. Message ids ascend.

    Message id 0 is reserved for messages from KBUS, and may or may not
    participate in this scheme. Message ids are held as unsigned 32-bit
    integers, and thus will eventually wrap.

Due to the internal queueing mechanisms used, messages order is deterministic.

Listeners
---------
Message recipients are called "listeners".

Listeners indicate that they want to receive particular messages. This is done
by:

1. Opening the appropriate kbus device.
2. Using the BIND ioctl on the resultant file descriptor to specify the name
   of the message that is to be listened for.

An ordinary listener will receive all messages with that name (on the relevant
kbus device). More bindings may be made by repeated use of the BIND ioctl.

Messages are received by reading the file descriptor.

A listener may bind to a wildcarded message name, in which case they will
receive all messages with names that match the wildcard.

If a listener no longer wants to receive a particular message name, then they
can unbind from it, using the UNBIND ioctl. The message name and flags used in
an UNBIND must match those in the corresponding BIND.

    Note that this has implication for binding and unbinding wildcards,
    which must also match.

Closing the file descriptor also unbinds all the message bindings made on it.
It does not affect message bindings made on other file descriptors.

Repliers
--------
For each message name, there may be a single "replier". A replier uses the
same binding mechanism, but sets the "REPLIER" flag in the BIND ioctl. If
someone else has already bound as a replier for that message name, the request
will fail.

Repliers only get messages that are marked as wanting a reply (requests).

A replier may (should? must?) reply to the request - this is done by writing
to the file descriptor.

    Thus, the kbus device can be opened read-only for a normal listener,
    but must be opened read-write for a replier, or if the same file
    descriptor is also to be used for sending messages.

It is perfectly legitimate to bind to a message as both replier and listener,
in which case two copies of the message will be read, once as replier, and
once as (just) listener. Only the message received as replier will be flagged
as needing a reply.

If a replier binds to a wildcarded message name, then they are the *default*
replier for any message names satisfying that wildcard. If another replier
binds to a more specific message name (matching that wildcard),
then the specific message name binding "wins" - the wildcard replier will no
longer receive that message name.

    In particular '$.Fred.Jim' is more specific than '$.Fred.%' which in turn
    is more specific than '$.Fred.*'

This means that if a wildcard replier wants to guarantee to see all the
messages matching their wildcard, they also need to bind as a listener for the
same wildcarded name.

Senders
-------
Message senders are called "senders".

A message is sent by:

1. opening the appropriate kbus device (for write)
2. writing a messsage to the resultant file descriptor

If there are no listeners bound to that message name, then the write will fail
(with error XXX).

If the message is flagged as needing a reply, and there are no repliers bound
to that message name, then the write will fail (with error XXX).

It is not possible to send a message with a wildcard message name.

    As a restriction this makes the life of the implementor easier.
    The original design didn't ask for it, either.
    Is there a use-case that requires us to allow sending to wildcards?
    I'd prefer there not to be. Not least because it gives messages with
    names that don't really *mean* anything.

If the message being sent is a request, then the replier bound to that
message name will (presumably) write a reply to the request. Thus the normal
sequence for a request is likely to be:

1. write the request message
2. read the reply

The sender does *not* need to bind to anything in order to receive a reply to
a request it has sent.

    Of course, if a sender binds to listen to the name it uses for its
    request, then it will get a copy of the request as sent, and it will
    also get (an extra) copy of the reply.

Stateful transactions
---------------------
It is possible to make stateful message transactions, by:

1. sending a message that requires a reply
2. receiving the reply, and noting the listener id of the replier
3. sending a message (normally, one needing a reply) to that specific listener
4. and so on

Sending a message to a particular listener will fail if that listener is no
longer bound to the relevant message name. This allows a sender to guarantee
that it is communicating with a particular instance of the replier for a
message name.

Guaranteed delivery, or not
---------------------------
Messages are sent by a mechanism which:

1. Takes the message
2. Finds the listener ids of all the listeners and repliers bound to that
   messages name
3. Adds the message to the queue for each listener

This can cause problems if one of the queues is already full (allowing
infinite expansion of queues would also cause problems, of couse).

There are two mechanisms that can be used to (help) avoid such problems.

Firstly, a listener can choose, when binding to a message name, whether or not
it is *guaranteed* to receive all messages with that name. If a listener is
not guaranteed to receive a particular message, and its queue is full, then
the message will not be added to its queue.

If a *replier* is not guaranteed to receive a particular message, and its
queue is full, then the message will not be added to its queue, and the sender
will be sent a synthetic message (an exception) to let it know that this has
happened.

    The synthetic message may only indicate that N messages have been lost,
    rather than having a message for each lost message.

Secondly, a sender can indicate if it wants a message to be:

1. Added to all the listener queues, regardless (subject to the above
   listener guarantee flags), in which case it will block until that can be
   done (ALL_or_WAIT, sender blocks)
2. Added to all the listener queues, and fail if that can't be done
   (ALL_or_FAIL)
3. Added to all the listener queues that *guarantee* to receive the message,
   and any other listener queues that have room (GUARANTEED)

Replying
--------
A sender can mark a message as needing a reply.

Sending such a message will fail if there is no replier bound for that
message.

The message will, as normal, be delivered to all listeners, and will have the
"needs a reply" flag set wherever it is received. However, the copy of the
message received by the replier will be marked as "you need to reply".

The replier should create a reply message with:

1. The same message name.
2. The "to" field set to the original message's "from" field (i.e., the
   reply message is specifically for the sender).
3. The "in_reply_to" field set to the original message's "id" field (i.e., it
   is a reply to that specific message). This field being non-zero is what
   distinguishes a reply message from an ordinary message.
4. The message data set to whatever is appropriate.

When a reply is sent, all listeners for that message name will receive it.
However, the original replier will not.

    So, if a particular file descriptor is bound as listener and replier
    for '.Fred', it will receive two copies of the original message (one
    marked as needing reply from that file descriptor). However, when the
    reply is sent, only the "plain" listener will receive a copy of the reply
    message.

Urgent messages
---------------
Messages may be flagged urgent. In this case they will be dealt with
separately -- this is still to be described.

    Consider: Urgent messages are meant to "jump the queue" in some sense
    (possibly just by being put to the front of the listener's queue).
    However, what if:

        a) the listener already asked for the next message length
           (and got a non-zero answer)
        b) that is not the message length of the newly inserted
           urgent message.

    This breaks the predictability of reading the next message. Any solution
    that requires the listener to cope with unexpected message lengths (when
    they think they've just dealt with that) is unacceptable - it makes the
    code to be written a pain.

    So perhaps the only solution is that, if the next message length has been
    read and is non-zero, and the corresponding message has not been read yet,
    then the urgent message must be "inserted" in such a way that it will be
    read after the message-whose-length-has-been-found has been read.

    Of course, if the message lengths match, then this need not be done...

Useful ioctls
-------------

    Reorganise this section later on, to make it easier to read/use.

There are ioctls to:

* BIND: Bind to a particular message name.

* UNBIND: Unbind a particular binding.

* BOUNDAS: Allow a listener to identify its listener id.

* REPLIER: Find out who is bound as replier to a particular message name. This
  returns 0 or the listener id of the replier.

* NEXTLEN: Find out the length of the next message (waiting to be read) on a
  file descriptor. This returns 0 or the message length.

Messages
--------
For the moment, see the C and/or Python code for the layout of a message.

Note the Python class Message, which makes message construction and
manipulation easier.

/proc/kbus/bindings
-------------------
``/proc/kbus/bindings`` is a debugging aid for reporting the listener id,
exclusive flag and message name for each binding, for each kbus device.

Error numbers
-------------
The following error numbers get special use. In Python, they are all returned
as values inside the IOError exception.

:EADDRINUSE:    On attempting to bind a message name as replier: There is
                already a replier bound for this message
:EADDRNOTAVAIL: On attempting to send a message: There is no listener bound
                for this message's name.
:EBADMSG:       On attempting to bind, unbind or send a message: The message
                name is not valid. On sending, this can also be because the
                message name is a wildcard.
:EINVAL:        Something went wrong (generic error).
:EMSGSIZE:      On attempting to write or send a message: The message data is
                too long.
:ENAMETOOLONG:  On attempting to bind, unbind or send a message: The message
                name is too long.
:ENOENT:        On attempting to open an Interface/open a '/dev/kbus<n>'
                device: There is no such interface/device (normally because
                one has tried to open, for instance, '/dev/kbus9' when there
                are only 3 KBUS devices).
:ENOMSG:        On attempting to send, when there is no message waiting to be
                sent (either because there has been no write since the last
                send, or because the message being written has been
                discarded).
:EPIPE:         On attempting to send 'to' a specific replier, the replier
                with that id is no longer bound to the given message's name.


// Local Variables:
// tab-width: 8
// indent-tabs-mode: nil
// c-basic-offset: 2
// End:
// vim: set filetype=rst tabstop=8 shiftwidth=2 expandtab:
