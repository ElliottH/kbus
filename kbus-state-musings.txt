====================
KBUS state - musings
====================

Starting from nothing and trying to work up to Richard's document...

Hopefully this will also give some sense of an order in which to implement
things.

Our motivation
--------------
We have a system where user A is receiving data many times a second from an
external source, and sending that data out via KBUS as a variety of messages.
Essentially, it is sending one message per incoming data packet.

User B is receiving those messages, and using them as a means of determining
the state of the external source.

The problem is that a *lot* of messages are being sent, because we're trying
to store the state of the external system in a flow of live messages. Almost
all of those messages are actually redundant, and are just loading the system
to no useful purpose.

It would be better if A only sent a message when the particular state changes,
but then we'd have a problem when B starts (it would not know the current
state). This also applies if B restarts, or if a new B' appears.

We're also using messages from B to A to cause requests for change to be sent
to the external source. Some of those changes are actually attempts to change
the same sort of state that we have incoming messages for. So potentially our
communication of state is not single directional.

Fit the first
-------------
Consider a KBUS user (Ksock) A which broadcasts some sort of current state, S.
This state may change fairly rapidly, so state messages are sent often. We
then have a recipient, B, who is interested in the value of S.

We have two consequent scenarios:

1. S changes rapidly, but B doesn't want to track all the changes, it only
   wants updates when it asks for them.

   We could ask A to only send updates every N seconds, but that doesn't
   work if B, C and D all have different ideas of the frequency they need.
   Which might change, of course.

2. A is receiving values for S rapidly, and updating S when it changes, but
   the value of S is not changing very often. B would like to be told when S
   changes, so that it does not receive all of the in-between messages.

   We could ask A to only send updates when S changes. However, we then have
   the case of when B starts to want values - it either has to wait for a
   message containing S (which might a long wait), or it has to enter into
   dialog with A to get the current value of S (which is a pain, and we'd
   really rather handle that case through some KBUS mechanism so the user
   doesn't have to keep reinventing it).

For simple state, we can do this with a relatively limited extension to KBUS.

For the moment, let's assume that we are "broadcasting" state - i.e., we have
one person, A, updating S, and zero to many people who are interested in the
value of S.

B can then subscribe to changes in S. It can then do either/both of two
things:

1. Ask what the current state of S is.
2. Ask to be sent a message (containing the current state of S) whenever S
   changes.

How do we tell if S has changed value? It sounds like it would be nice if KBUS
detected that for us, but unfortunately we don't want KBUS to know anything
about the meaning of the bytes in message data, so that won't work.

  It *could* do a byte-by-byte comparison. But that would be slow, and, in
  general, would give a wrong answer. First of all, we might have floating
  point numbers in our state value, but regard 0.001 and 0.002 as the same
  within tolerance. And secondly, our state might be complex, and some sets of
  internal values might be considered equivalent (mode START and READY might
  be identical for our purpose, even though needing to be transmitted as
  different values).

So we do have to assume that A will only send a new value of S when it has
changed.

Our requirements are thus:

1. B *subscribes* to message S.

   a. B wants, or does not want, to get a new message when state-of-S changes,
      in which case it gets a message S at appropriate times.

      This sounds suspiciously like binding to a special message, "update of
      S", as a standard listener. This turns this into a (message) naming
      problem...

        *B binds to "$.STATE.OF.<S>"*

        NB: I imagine we forbid wildcards in "$.STATE.OF." message names, and
        that the binding is automatically marked as MSGONLYONCE.

   b. B can ask KBUS for the current state of S, in which case it gets a
      message S containing the current state.

      This sounds supiciously like sending a Request, "give me S", to KBUS
      itself (i.e., KBUS would be the Replier for such messages), and getting
      back a Reply with the state in it. Again, a naming problem.

        *B requests "$.STATE.OF.<S>"*

   c. B wants to receive changes in S, but not more often than once per N
      seconds.

        *B binds to "$.STATE.OF.<S>" with minimal interval N*

      So if A changes S 10 times every N seconds, B will only get a single
      message every N seconds,

      However, if A changes S every 10*N seconds, B will get every change in
      S.

      (If A changes S, and then changes it again 7 times separated by N/10,
      and then doesn't change it again for 10*N, should KBUS send the first S
      and then delay the eighth until N? How complicated should we be?)

2. A *declares* that it is setting a state S.

   a. A needs to be able to publish a new state of S, which KBUS will
      remember.

        *A sends "$.STATE.OF.<S>" with appropriate data*

   b. Does A need to declare how big the data for S is, or can be? Being able
      to define at least a maximum size sounds like a good idea. This would
      presumably be done via IOCTL.

   c. KBUS needs to ensure that B can't get a value for S whilst A is writing
      it, Whilst low-level message reading and writing are "atomic" (i.e.,
      that's the level at which KBUS locks), a user-level read/write may be
      split into several of the low-level calls.

      For the moment, we'll just assume that the internal state of S is only
      changed when the last part of the write operation completes - i.e., it
      is finalised when A thinks it is.

What we've described so far does a simple job with some magic provoked by
naming - this would appear to be the minimal change we can get away with
("messages starting $.STATE.OF. are special"). It's likely not to be a good
idea if we have a large amount of state data, though, as we're still
transferring the data in our messages.

It doesn't particularly describe what happens if we have multiple senders (A1,
A2, ...) all sending new values for S, and it doesn't describe how we might
cope with large data contents in S.

Fit the second
--------------
KBUS level read and write are atomic (that's the level we lock at), but user
level read and write may not be, as they may result in multiple calls to the
KBUS functions.

This is specifically a problem if A and A' both try to set the state of S.

Thus we should probably say that, in the scheme described above, whoever
started a write has gained control over the amendment of the state, and has it
until their write finishes. Thus A would have control, and A' would get an
error if it tried to write "at the same time".

If A dies, mid way through, then KBUS knows this, and it would have to throw
away the partial write from A.

  (Since this is all being done by the system, I don't think we need an
  abort/rollback mechanism of any greater complexity, for this purpose.)

Note that this is essentially similar to what can happen already with writes -
the user level call may, for instance, fail because there is no room in the
intended recipient's message queue.

Fit the third
-------------
Do we cope with A dying and A' taking over management of state S?

Since KBUS identifies A via its Ksock, it does know when it is closed (whether
because it died or some other reason), so it can know that this has happened.

However, the mechanism as given above doesn't much care - as normal, anyone
can send messages modifying S.

If B asks for the state in the gap between A and A', it should just get the
last state, as normal.

Which leaves us with the important question:

  * Does the internal state for S go away when both A and B have gone away?

Well, as described above, KBUS knows that B cares about S, but may not have
bothered to remember that A does. Maybe it should remember any Ksock that has
set the state of S, and consider it an interested user - in which case we
could allow the state of S to vanish when no A or B is left.

*Or* we could have a pair of explicit calls, one to setup the internal state
for S, and the other to declare it of no further interest:

  *Declare new state S*

  *Forget state S*

That last would obviously have to fail if any B was still bound to the
"$.STATE.OF.<S>" message name. Would it also fail if any A was still open?
(probably not, since A is the most plausible person to be calling it!).

Clarifying:

* When B subscribes to S, we've already said it sets the equivalent of
  MSGONLYONCE. Let's make that explicit - if B tries to subscribe to S more
  than once, only the first has any effect. KBUS then remembers that B has an
  interest in S.

* When A declares a new state S, it also registers as interested. This is a
  *counted* value - so if A declares again, that count is incremented.

* When A forgets state S, its interest count is decremented.

* If A or B closes its Ksock (for whatever reason), its interest in S becomes
  zero.

So if A, A (again), A' and B all have interest in S, and A and B die, there is
still an interest from A', and the resources for S will not go away.

We *might* also want to be able to declare a *persistent* state, P, which
never goes away (except when KBUS itself does).

Fit the fourth
--------------
Transactions. Simple transactions.

The use case for this becomes obvious when we want two Ksocks to be able to
read and write state S "at the same time".

We want to be able to do::

  B starts a transaction, within which no-one else can affect S

    B reads the current values of S

    B thinks a bit

    B writes a new value of S, presumably based on its thoughts

    B does commit

  <and the transaction is now over>

* If someone other than B tries to write S during the transaction, this will
  fail.
* If someone other than B tries to read S during the transaction, they will
  get the original (pre-transaction) value of S.
* If someone tries to start another transaction on S during the transaction,
  this will fail (but see the next fit for discussion of nested transactions).

Note that B might decide not to write anything (to S) so there must be another
way of explicitly ending the transaction. We could call that rollback, or
abort, depending.

During the transaction, other users (other Ksocks) do not perceive S as
changing. It is only at the moment of commit that their view of S changes.

Also consider::

  B starts a transaction

    B reads the current values of S, S.0

    B thinks a bit

    B writes a new value of S, S.1

    B reads S a second time - what happens?

    B writes a new value of S, S.2

    B does commit

  <and the transaction is now over>

Does B see S.0 or S.1 on that second read? Ideally, they'd see S.1.

Is that second write allowed, within the same transaction? Hopefully, yes.

I don't think it is *required* that transaction support be part of KBUS
itself, if there is a more efficient way of doing it in userspace (Richard
suggests basing things around futexes). Everyone would just have to promise
not to cheat.

Fit the fifth
-------------
Nested transactions are requested.

Ideally, transactions should be nestable, so that user code can be simpler
(i.e., library code doesn't have to keep track of whether there is already an
open transaction).

.. note:: We could say that:

   1. A transaction relates to a state S, and belongs to the Ksock K that
      started it. Once K starts a transaction on state S, no other Ksock may
      start a transaction on state S, until such time as K ends its
      (outermost) transaction.

   2. K may start more than one transaction on the same state S. Starting
      such a nested transaction shall be equivalent to incrementing a nested
      transaction counter for S.

   3. Committing inner transactions simply decrements the nested transaction
      counter. It is only committing the outermost transaction that actually
      commits the change of state.

   4. If an inner transaction aborts/rolls back, then the outermost
      transaction is also considered to have aborted/rolled back. This makes
      sense if we are assuming that the outer most transaction depends on the
      success of the inner transactions (which is a natural way to look at
      it).

      So, if an inner transaction aborts, it will not be possible to commit
      any transactions that contain it. If we're using a simple nested
      transaction counter approach, this is also probably the simplest way to
      work.

   5. A transaction on a different state is not a nested transaction, for
      this discussion.

I think this immediately requires us to have explicit transaction ids, so that
it can be made clear what transaction a commit or abort is referring to.

So, K starts a transaction on S (T.0), and then whilst that transaction is
still active, K starts another transaction on S (T.1).

So, consider::

    K starts T.0, original state S.0

    reading S gives S.0
    writing S sets S to S.0.1

                                    K starts T.1, original state S.0.1

    reading S gives S.0.1           reading S gives S.0.1
    writing S fails, T.1 exists     writing S sets S to S.0.1.1

                                    T.1 commit, final state S.0.1.1

    reading S gives S.0.1.1
    writing S sets S to S.0.2

    T.0 commit, final value S.0.2

Anyone other than K will see state S.0 until the final, outer, commit has
succeeded.

So, some questions arise:

1. What happens if T.1 is aborted (rolled back)?

   a. T.1 is aborted, T.0 continues with S as S.0.1

      This approach regards the inner transactions as "proper" transactions,
      which are essentially independent of their outer.

   b. T.1 is aborted, T.0 is also aborted. Thus the attempts to
      read/write/commit within the rest of T.0 will/would all fail
      with some appropriate error.

      This approach regards "abort" as "polluting" the entirety of whatever
      outer transaction is in force.

Now consider what happens if we commit the outer transaction before the
inner?  ::

    K starts T.0, original state S.0

    reading S gives S.0
    writing S sets S to S.0.1

                                    K starts T.1, original state S.0.1

    reading S gives S.0.1           reading S gives S.0.1
    writing S fails, T.1 exists     writing S sets S to S.0.1.1

    attempt T.0 commit

                                    attempt T.1 commit

If inner transactions really are "real", then we're going to get this
situation.

Options seem to be:

* The commit of T.0 fails, as there is an outstanding inner transaction.
* The commit of T.0 succeeds, S becomes visible as S.0.1, and any attempt to
  do a read/write/commit within T.1 will now fail.
* The commit of T.0 succeeds, but first it commits T.1. This would seem like
  the worst possible choice.

.. note:: Richard would really like transactions to be independent, so a
   nested transaction can be rolled back (aborted) *by the user* without
   necessitating the ending of an outer transaction.

   I think I'm only going to be happy when I've got actual use-cases and some
   implementation to play with.

Fit the sixth
-------------
If B is trying to find out the current state of S, it may need to do it fast
and frequently. The overhead of doing a message exchange (request current
state, arrange to receive the reply, actually receive the reply) is a lot of
overhead, both in programming (the request/reply handling, which may involve
callbacks to handle the receipt of the reply) and also in work (the system
calls, and the actual message handling, and the copying of the state data
across the user/kernel interface). So we'd like a different solution, allowing
B to "just look" at something - and the natural solution is some shared
memory.

Meanwhile, the data for state S may have multiple parts, and those parts may
change at different frequencies. If S is quite large, sending or receiving
*all* of S when only one part of it is changing is again too much overhead. So
this is another indication that S does not belong inside the messages. Again,
the obvious thing to use is shared memory.

This all means that we don't want to use KBUS for such state, although we can
sensibly use it for passing information *about* the state (e.g., "state S has
changed").

However, if we're going to have a shared memory data structure, then we
definitely need some sort of transaction handling infrastructure, to make sure
that our read and write accesses make sense. At which point, we do have a
module or library handling the multiple versions of our state that we will
necessarily have.

So, first we need to sort out access to the state. We can continue to use a
state *name*, S, but now our Ksock is not relevant (we're not bound tightly to
KBUS), so instead we're using our current process as accessor - i.e., it can
be implicit.

Which means we have::

  <state> = subscribe(S, permissions)

where ``permissions`` is some combination of ``read`` and ``write`` flags.

We then also have::

  err = read(<state>, offset, length, &buffer)

which reads ``length`` bytes from offset ``offset`` into ``buffer`` (which
must be at least ``length`` bytes long). Bounds checking will be done on
``offset`` and ```length`` with respect to the data actually available in
``<state>``.

Clearly ``read`` may fail with a RETRY error for that moment when the actual
state is being updated (and our job is to keep that time as short as
possible).

We can also have::

  err = write(<state>, offset, length, buffer)

which writes ``length`` bytes from ``buffer`` to ``offset`` within
``<state>``. Again, bounds checking will be done with respect to the data area
in ``<state>``.

.. note:: We'll see below that there is an implicit transaction around
   ``write``.

Starting a transaction needs to return a handle identifying it, so::

  <transaction> = transaction(<state>)

indicates that we have started a transaction on ``<state>``. While this
transaction is ongoing, it will not be possible for another process to start a
transaction on ``<state>``, or to write to it.

Committing a transaction obviously does so with respect to that handle::

  err = commit(<transaction>)

as does aborting::

  err = abort(<transaction>)

For convenience, we want to be able to pass a ``<transaction>`` handle to
``read`` and ``write``, as well as the ``<state>`` they were previously
expecting.

Also for convenience::

  err = write(<state>, offset, length, buffer)

should actually behave as if it were::

  <transaction> = transaction(<state>)
  err = write(<transaction>, offset, length, buffer)
  if err:
    abort(<transaction>)
  else:
    commit(<transaction>)

This means that if you are already in a transaction, you really do want to
pass that ``<transaction>`` to ``write()``, so that it can tell it doesn't
need to introduce a spurious inner transaction.

Whether we believe the same about ``read`` or not is a matter I'll worry about
later.

.. note:: Accessing the shared memory via opaque handles like this means that
   the caller doesn't need to worry about how transactions actually manage
   memory. This has the advantage that we can change the mechanism, if we
   wish.

   One obvious way to do it is for a transaction to (notionally) take a copy
   of the state's data at its start, and use copy-on-write to maintain the
   state as amended by the transaction. It can then simply "flip" which
   copy of the state's data is being used at the end of the transaction.

   Of course, that initial copy may itself only be made if actually necessary.

.. note:: We don't want to provide any direct acccess to the internal pointers
   to shared memory, attractive though that might seem.

   Imagine if we had a function::

     ptr = get_ptr(<handle>)

   That ``ptr`` would be transient, particularly over calls of ``write``
   (since we don't know what happens to the underlying data when we do a
   write), and it would also obviously be invalid after a ``commit`` or
   ``abort``. None of those are *enforceable* though, so it would be terribly
   easy to end up misusing the pointer. Also, since it *is* just a pointer,
   we've got no option for bounds checking the amount of data being accessed
   through it.

I *think* that once we've got all of that working, we can add the KBUS support
"on top".

Reviewing our initial requirements:

1. B wants to be notified when S is changed.

   This is done by sending a KBUS message to anyone who cares when an outer
   level commit happens.
   
   Note that this means we have to be able to tell we're dealing with an outer
   level commit.

   The message name should be automatically derieved from the state name.

   We should presumably be able to cause this by passing a Ksock to something
   - possibly our initial ``subscribe``.

2. B wants to determine the current state of S.

   This is done by using ``read`` directly.

3. B wants to receive changes in S, but not more often than once per N
   seconds.

   This does require an amendment to KBUS, to allow it to filter the
   messages from case (1). It's a useful general case for message handling, I
   think. We'd need a new binding mechanism::

     err = kbus_ksock_bind_filter(ksock, name, max_freq)

   which say says that we want to bind to message ``name`` as a listener, but
   not receive more than one message every ``max_freq`` seconds.

   This clearly belongs at the listener end of the message system, since
   different listeners are going to have different frequencies.


Question: Should our ``state`` allow for ``components``?

We said earlier on that we might have a state that has components which are
updated at different frequencies. Putting it another way, we may allocate an
area of shared memory where some parts of it are written more often than
others. It might be nice to be able to identify these as such, both for
convenience of access, but also for convenience of messaging - i.e., having
different messages for updating of the different components.

If we do this, I'm going to assert that it will only be a single level of
division - i.e., components of the state, but not subcomponents.


.. vim: set filetype=rst tabstop=8 softtabstop=2 shiftwidth=2 expandtab:
