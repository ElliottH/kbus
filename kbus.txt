====
KBUS
====

We support sending a MESSAGE to an OBJECT and maybe waiting for a REPLY.

Object names
============
Object names are hierarchical, and textual, of the form:

* a "$" to flag the top of the hierarchy
* a series of one or more "." and node name, giving a name tree

For instance::

    $.Video.Player
    $.System.Query

Wildcards allow us to specify all object names that start with a sequence::

    $.Video.*

and object names that end with the same node name::

    $.Video.%


For example:

    -------     -------------   -------------
    Name        $.A.* matches   $.A.% matches
    -------     -------------   -------------
    $.A         no              no
    $.A.B       yes             yes
    $.A.C       yes             yes
    $.A.B.C     yes             no
    -------     -------------   -------------

Messages
========
Each message has a 32 bit message id (is this ever of any use outside the
kernel module?).

There are three types of message:

1. Asynchronous events -- no reply
2. Asynchronous method calls -- expect a reply (if there are more than one
   recipient, we may get more than one reply - this is the senders problem).
   If there are no recipients left for this method call, then the kernel
   module will "make up" a "no one listening" reply (a synthetic reply)
3. Method replies -- including Exceptions and Synthetic replies.

When a recipient binds to an object (i.e., says "I want to receive messages
for this object name"), it *can* declare that binding EXCLUSIVE. That means it
is the only recipient who will (who is allowed to) receive messages for that
object. That allows one to guarantee that there will only be a single reply to
any method called on that object.

There are actually two mesage queues, one for normal mesages, and one for
urgent messages. Urgent messages take priority. For instance, think about
sending a series of trickplay events to a video player. An Urgent message
could be use to send the "Stop" event. This would cause the video player to
unbind from the particular object name, and then the kernel module would
generate "gone away" synthetic events for any remainng messages to that object
name left in the "normal" message queue.

Kernel module
=============
The kernel module provides the following "file" interfaces:

* /dev/kbus -- used for messaging
* /proc/kbus/objects -- returns the information about the existing object
  names, their corresponding ids, and which file descriptors are listening to
  what (including whether they are listenind to wildcards).
* /proc/kbus/interfaces -- TBD
* /proc/kbus/stats -- gives some sorts of statistics/activity information --
  TBD

/dev/kbus
---------
The following can be done:

* ``int fd = open("/dev/kbus")`` -- in the normal manner

* ``int ret = close(fd)`` -- in the normal manner. Unbinds any bindings,
  causes any outstanding messages that are only destined for this fd to be
  flushed and synthesised returns made if necessary.

* ``ssize_t ret = write(fd, void *buf, size_t count)``

  ``buf`` is a message of size ``count``, and must be "shaped" as such.

* ``ssize_t ret = read(fd, void *buf, size_t count)``

  In the normal way, blocks until a message is available for (any of) the
  object names this fd is bound to, and then provides (up to) the next
  ``count`` bytes of that message.

* ``int ioctl(int d, int request, ...)``

  Useful other things -- for instance:

  * bind to object name -- this allows the caller to say that this fd is to
    receive messages for the given object name. This last may be wildcarded.
    More than one bind may be made for a single fd. The same object name may
    be specified more than once (either directly or via wildcarding), in which
    case the fd will receive a message for that object name the corresponding
    number of times. The *order* of those (identical) messages to those
    (identical) object names is, of course, not significant.

  * unbind from object name -- this allows the caller to say that this fd does
    not wish to receive messages for the given object name. The string given
    as an object name must match exactly one of the strings given to ``bind``
    for the same fd. If an object name was bound more than once (whether by
    wildcarding or not), it must be unbound by corresponding calls that match
    exactly.

  * drop-message -- MAYBE -- discards the rest of the message that is being
    read with ``read``. Maybe returns 0 if there is no next message(?)

* *Maybe* provide ``poll`` as well, to allow a caller to tell if a read/write
  would block. Maybe.


.. ---------------------------------------------------------------------------
.. vim: set filetype=rst expandtab shiftwidth=4:
